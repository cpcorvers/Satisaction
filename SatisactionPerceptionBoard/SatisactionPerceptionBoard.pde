/********************
 * IMPORT
 *******************/
import processing.serial.*;
import gausstoys.core.*;
import websockets.*;
import processing.net.*;
import java.util.*;

/********************
 * INIT
 *******************/
GaussSense gsMeta;
GaussSense[] gs = new GaussSense[2];
boolean showContour = true;
boolean testBoard = false; //false: JSON files are created, true: JSON files are not created!
int thld = 6/2 ; //Unit: Gauss
boolean horizontalGrid = true;

// background images
PImage playingfield;
String[] bgBoard = {"playingfield1.png", "playingfield2.png", "playingfield3.png", "playingfield4.png" };
int bgBoardIndex = 0;

PImage perspectives;
String[] bgScreen = {"perspective1.png",  "perspective3.png", "perspective4.png", "perspective5.png", "perspective6.png", "perspective7.png" };
int bgScreenIndex = 1;
PImage person_abstract;

// INIT SECOND SCREEN / SERVER CLIENT
//Server s;
//Client c;
String input;
String newInput;
int data[];
int port = 4000;

int boardScreen = 0;

// INIT 'databases'
Person p;
ArrayList<Person> boardPawns;
ArrayList<Person> screenPersons;
ArrayList<Person> historyPersons;

float scaleX = 1.4900; //1.373 //width of screen
float scaleY = 1.550; //1.350 //hight of screen
float offsetX = 10; // 76;
float offsetY = 10; // 65;

JSONObject json; //the object stored in the data.json file
JSONArray pawns; //the array inside the jsonObject json
JSONArray boardVisual;
JSONObject pawnParameters; //the object inside the jsonArray pawns
int recordArrayPawns = 0;
JSONObject pawn;
String jsonFile = "data/data.json";
String jsonFile_0 = "data/data0.json";

//INIT Display variables
int boardDisplayWidth = 1920;
int boardDisplayHeight = 1080;
int screenDisplayWidth = 1280;
int screenDisplayHeight = 800;
// int screen = 0;

int previousTime = 0;
int interval = 1000;

float t;
float identity;

void settings() {
  fullScreen(P2D, boardScreen);
  //size(1920,1080, P2D);
}

/********************
 * SETUP FUNCTION
 *******************/
void setup() {
  // START THE SERVER
  //s = new Server(this, port); // Start a simple server on a port
  //c = new Client(this, "10.0.1.3", port); 
  
  frameRate(20);
  playingfield = loadImage(bgBoard[bgBoardIndex]);

  // List all serial ports
  // GaussSense.printSerialPortList();

  //Initialize the GaussSense
  for (int i = 0; i < 2; i ++) {
    gs[i] = new GaussSense(this, GaussSense.GSType.GAUSSSENSE_BASIC, Serial.list()[Serial.list().length - (i+1)], 115200);
    gs[i].setCalibrationFileName("BASIC-"+i+".data");
  }
  gsMeta = new GaussSense(this, GaussSense.GSType.GAUSSSENSE_BASIC, 2, 1);

  // Intitialize the arrays for pawns and persons
  boardPawns = new ArrayList<Person>();
  screenPersons = new ArrayList<Person>();
  historyPersons = new ArrayList<Person>();

  json = new JSONObject();
  pawns = new JSONArray();
  // pawn = new JSONObject();

  perspectives = loadImage(bgScreen[bgScreenIndex]);
  person_abstract = loadImage("27.png");

  println("Setup complete");
  // println("display: " + displayWidth + "," + displayHeight);
}

/********************
 * DRAW FUNCTION
 *******************/
void draw() {
  background(250);

  // create boardvisual on the boardscreen with keypress to switch images
  pushMatrix();
  translate(boardDisplayWidth, 0);  
  rotate (PI/2);
   //image(playingfield, 0,  0, displayHeight, displayWidth );
  image(playingfield, 0, 0, boardDisplayHeight, boardDisplayWidth );
  popMatrix();

  //Set variables for drawing single-layer contour map
  //Try to change the Thld to see the results
  int upsampleFactor = 5;

  for (int i = 0; i < 2; i ++) {
    if (gs[i].getAdditionalData().size()>0) {
      int s = gs[i].getAdditionalData().get(0);
      //println(s);
      if (s == '1') gsMeta.set(gs[i], 0, 0, 2, false, false);
      if (s == '2') gsMeta.set(gs[i], 1, 0, 2, false, false);
    }
  }

  // show visuals as generated by the GaussSense product and software if showContour == true in INIT
  pushMatrix();
    translate(offsetX, offsetY);
    scale(scaleX, scaleY);
    if (showContour) {
      //Set and draw the upsampled contour map
       gsMeta.drawUpsampledContourMap2D(1280, 640, upsampleFactor, thld);
    } else {
      //Set but don't draw the upsampled contour map
      gsMeta.setUpsampledContourMap2D(1280, 640, upsampleFactor, thld);
    }
    // gsMeta.drawBasicGaussBits(); //draw a circle around the sensed magnets
  popMatrix();

 if (millis() - previousTime >= interval) {
   //receive data from GaussSense, create Person in Arraylists and add Person.parameters using class Person
   getGaussData();

   getPawnCenter();
   getTimestamp();
    if (testBoard == false){ createJSONObject(); };
   previousTime = millis();
   println(pawns.size() + " at " + previousTime);
 }
   //visualize a pawn on the boardscreen and send Person.parameters to the clients
   dataVisualisation();

  // only for coding and debugging:
  // println(boardPawns.size() + " " + screenPersons.size() + " " + historyPersons.size());
  // println(pawns.size());
  // println(pawn);
}

void getGaussData() {
  emptyBoardPawns();
  //Receive data from the GaussSense sensors and store in an Arraylist
  ArrayList<GData> bGaussBitsList = gsMeta.getBasicGaussBits(thld);//API Demos
  for (int j=0; j < bGaussBitsList.size(); j++) {
    GData bGaussBits = bGaussBitsList.get(j);
    int polarity = bGaussBits.getPolarity(); //Get the polarity in Int. 0: North, 1:South

    int intensity = (int) bGaussBits.getIntensity(); //Get the intensity. Unit: gauss
    int x = round((int) bGaussBits.getX()); //Get the X coordinate on the display
    int y = round((int) bGaussBits.getY()); //Get the Y coordinate on the display
    // String polarityString = (polarity==0 ? "North" : "South" );
    int xx = round(((int) x * scaleX));
    int yy = round(((int) y * scaleY));
 
    boardPawns.add(new Person(xx, yy, polarity, intensity));
   }
  
  // Empty ArrayList boardPawns when sensors give no data
  if (bGaussBitsList.size() == 0){ emptyBoardPawns(); }
  // Avoiding full of memory exeption by restricting the size of the ArrayLists
  if (boardPawns.size() > 200) {
    for (int i = 0; i < (boardPawns.size() - 200); i++){ boardPawns.remove(i); }
  }
  if (screenPersons.size() > 200) {
    for (int i = 0; i < (screenPersons.size() - 200); i++){ screenPersons.remove(i); }
  }
  if (historyPersons.size() > 200) {
    for (int i = 0; i < (historyPersons.size() - 200); i++){ historyPersons.remove(i); }
  }
}

void emptyBoardPawns(){
  for (int i = 0; i < boardPawns.size(); i++) {
    Person cp = boardPawns.get(i);
    boardPawns.remove(i);
  }
}
void getPawnCenter(){
  float x1;
  float y1;
  float x2;
  float y2;
  // for (Person cp1 : boardPawns) {
  for (int i = 0; i < (boardPawns.size()); i++){
    Person cp0 = boardPawns.get(i);
    if (cp0.pawn_polarity == 0){
      float recordDC = 500;
      Person matchedCenter = null;
      // for (Person cp2 : boardPawns) {
      for (int j = 0; j < (boardPawns.size()); j++){
        Person cp1 = boardPawns.get(j);
        if (cp1.pawn_polarity == 1){
          PVector center0 = cp0.getCenter();
          PVector center1 = cp1.getCenter();
          float dc = PVector.dist(center0, center1);
          if (dc < recordDC && !cp1.takenCenter ) {
            recordDC = dc;
            matchedCenter = cp1;
          }
          if (matchedCenter != null) {
            matchedCenter.takenCenter = true;
            x1 = cp0.pawn_x;
            y1 = cp0.pawn_y;
            x2 = matchedCenter.pawn_x;
            y2 = matchedCenter.pawn_y;
            matchedCenter.pawnCenterX = (x1 + x2) /2;
            matchedCenter.pawnCenterY = (y1 + y2) /2;
            // calculate the direction of the pawn by the angle between the two magnets of the pawn
            float degreePawn = atan2( (y2 - y1) , (x2 - x1));
            float degree = degreePawn + PI / 2;
            matchedCenter.direction = degree; //radians(degree);
            cp0.becomePawnCenter(matchedCenter);
          }
        }
      }
    }
  }
}

void getTimestamp() {
  int time = (int)(new Date().getTime() / 1000);
  //  var timestamp = parseInt(new Date().getTime() / 1000);
  int timeStamp = abs((int)time);
  for (Person p : boardPawns) {
    p.timestamp = timeStamp;
    //println("this is: " + p.timestamp);
  }
}

void dataVisualisation() {
  // show every person which is taken==true
   for (int i = 0; i < (boardPawns.size()); i++){
  //for (Person p : boardPawns) {
    //if ( p.pawn_polarity == 1) {
          Person p = boardPawns.get(i);
    if (p.pawn_polarity == 1){
      p.showPawn(p.pawnCenterX, p.pawnCenterY, p.identity, p.direction);
      //p.showPawnTesting(p.pawnCenterX, p.pawnCenterY, p.identity, p.direction, p.pawn_intensity);
      //p.showPawn(p.pawnCenterX, p.pawnCenterY, p.identity, p.direction);
    }
  }
}

void createJSONObject() {
  json = loadJSONObject(jsonFile);
  //json = loadJSONObject(jsonFile_0);
  println("jsonFile loaded");
  //JSONObject ammount = new JSONObject();
  pawns = json.getJSONArray("pawns");
  println(pawns.size());
  println(boardPawns.size());
  
  for (int i = 0; i < boardPawns.size(); i ++) {
    pawn = new JSONObject();
    Person p = boardPawns.get(i);
    // int zomaar = p.timestamp;
    // println("zomaar: " + zomaar);
    p.becomeJSONObjectPawn();
    //pawns.append(pawn);
    pawns.setJSONObject(i, pawn);
    //boardPawns.remove(i);
  }
  int ammountNum = boardPawns.size();
  json.setInt("ammount", ammountNum);
  println(json);
  saveJSONObject(json, jsonFile);
}

void keyPressed() {
  //CHANGING PLAYINGFIELD BACKGROUND WITH Q AND W KEYPRESS
  if (key == 'q') {
    if (bgBoardIndex > 0) {
      bgBoardIndex-- ;
    } else {
      bgBoardIndex = bgBoard.length-1;
    }
    playingfield = loadImage(bgBoard[bgBoardIndex]);
  } else if (key == 'w') {
    if (bgBoardIndex < (bgBoard.length-1)) {
      bgBoardIndex++ ;
    } else {
      bgBoardIndex = 0;
    }
    playingfield = loadImage(bgBoard[bgBoardIndex]);
  } else if (key == 'n') {
    // println(pawnsOnDigiboard);
  }
}
